# -*- coding: utf-8 -*-
"""student-04-5859cc09764d (Aug 28, 2025, 11:32:37â€¯AM)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/embedded/projects/qwiklabs-gcp-02-0b35817aba3e/locations/us-central1/repositories/9673a6a7-bc45-4d45-bfc2-ae3096f03bc1
"""

# Commented out IPython magic to ensure Python compatibility.
# %%bigquery
#  CREATE SCHEMA IF NOT EXISTS airport_weather_alert
#  OPTIONS(
#  location="us",
#  default_table_expiration_days=14 );

# Commented out IPython magic to ensure Python compatibility.
# %%bigquery
#  CREATE OR REPLACE EXTERNAL TABLE `qwiklabs-gcp-02-0b35817aba3e.airport_weather_alert.airport_weather_table`
#  OPTIONS (
#    format = 'CSV',
#    uris = ['gs://labs.roitraining.com/data-to-ai-workshop/airports.csv'],
#    skip_leading_rows = 1,
#    allow_jagged_rows = false,
#    allow_quoted_newlines = false,
#    field_delimiter = ',',
#    max_bad_records = 10
#  );

# Install necessary packages
!pip install google-cloud-bigquery pandas db-dtypes google-cloud-aiplatform --upgrade --quiet
import pandas as pd
import requests
import time
from google.cloud import bigquery
import vertexai
from vertexai.generative_models import GenerativeModel

# --- Configuration ---
# PLEASE EDIT THESE VALUES
PROJECT_ID = "qwiklabs-gcp-02-0b35817aba3e"  # @param {type:"string"}
LOCATION = "us-central1"            # @param {type:"string"}
DATASET_ID = "airport_weather_alert"                # @param {type:"string"}
SOURCE_TABLE = "airport_table"           # @param {type:"string"}
DESTINATION_TABLE = "airports_with_forecast_alerts" # @param {type:"string"}

# Set a limit for the number of airports to process.
# Set to None to process all large airports.
PROCESSING_LIMIT = 5000 # @param {type:"integer"}


# --- Initialize Clients ---
vertexai.init(project=PROJECT_ID, location=LOCATION)
bq_client = bigquery.Client(project=PROJECT_ID)

# --- Function Definitions ---

def get_extended_weather_forecast(latitude: float, longitude: float) -> list | None:
    """
    Fetches the extended weather forecast from the NWS API for a given lat/lon.

    Args:
        latitude: The latitude of the location.
        longitude: The longitude of the location.

    Returns:
        A list of forecast dictionaries, or None if an error occurs.
    """
    if pd.isna(latitude) or pd.isna(longitude):
        return None
    try:
        # 1. Get the forecast URL for the given coordinates
        points_url = f"https://api.weather.gov/points/{latitude:.4f},{longitude:.4f}"
        headers = {'User-Agent': 'VertexAI-Colab-Script'}
        points_response = requests.get(points_url, headers=headers, timeout=10)
        points_response.raise_for_status()
        forecast_url = points_response.json()['properties']['forecast']

        # 2. Get the actual forecast data
        forecast_response = requests.get(forecast_url, headers=headers, timeout=10)
        forecast_response.raise_for_status()

        # 3. Parse and format the forecast periods
        periods = forecast_response.json()['properties']['periods']
        return [
            {
                'name': p.get('name'),
                'startTime': p.get('startTime'),
                'temperature': p.get('temperature'),
                'temperatureUnit': p.get('temperatureUnit'),
                'windSpeed': p.get('windSpeed'),
                'windDirection': p.get('windDirection'),
                'shortForecast': p.get('shortForecast'),
                'detailedForecast': p.get('detailedForecast')
            } for p in periods
        ]
    except requests.exceptions.RequestException as e:
        print(f"  [Weather API Error] Could not fetch forecast for ({latitude}, {longitude}): {e}")
        return None
    except (KeyError, IndexError) as e:
        print(f"  [Weather API Error] Could not parse forecast for ({latitude}, {longitude}): {e}")
        return None


def create_airport_alert(detailed_forecast: str) -> str | None:
    """
    Uses Gemini to create a concise operational alert for pilots.

    Args:
        detailed_forecast: The detailed text forecast for a time period.

    Returns:
        A one-sentence alert string, or None if an error occurs.
    """
    if not detailed_forecast:
        return "No detailed forecast available."

    try:
        model = GenerativeModel("gemini-2.0-flash")
        prompt = f"""
        You are an expert aviation meteorologist creating flight operations advisories.
        Based on the following detailed weather forecast, provide a concise, one-sentence operational alert for pilots.
        Focus only on conditions that could impact take-off, landing, or flight, such as significant wind, gusts, low visibility, or precipitation.
        If conditions are calm and clear, state that.

        Forecast: "{detailed_forecast}"

        Alert:
        """
        response = model.generate_content(prompt)
        return response.text.strip()
    except Exception as e:
        print(f"  [Gemini Error] Could not generate alert: {e}")
        return "Alert generation failed."


# --- Main Execution Logic ---

print(f"Starting airport forecast processing for project '{PROJECT_ID}'...")

# 1. Query BigQuery for large airports
limit_clause = f"LIMIT {PROCESSING_LIMIT}" if PROCESSING_LIMIT is not None else ""
query = f"""
    SELECT
        *
    FROM
        `{PROJECT_ID}.{DATASET_ID}.{SOURCE_TABLE}`
    WHERE type = 'large_airport' AND iso_country = 'US'
    {limit_clause}
"""

print(f"Fetching data from BigQuery table: `{DATASET_ID}.{SOURCE_TABLE}`")
try:
    df = bq_client.query(query).to_dataframe()
    print(f"Successfully fetched {len(df)} large airports to process.")
except Exception as e:
    print(f"BigQuery query failed: {e}")
    df = pd.DataFrame() # Create empty dataframe to prevent further errors


# 2. Process each airport to get forecast and Gemini alert
if not df.empty:
    processed_airports = []
    total_airports = len(df)

    for index, airport in df.iterrows():
        print(f"\nProcessing {index + 1}/{total_airports}: {airport['name']} ({airport['ident']})")

        # Get weather forecast
        forecasts = get_extended_weather_forecast(airport['latitude_deg'], airport['longitude_deg'])

        # Prepare a dictionary for the new row
        new_row = airport.to_dict()

        if forecasts and len(forecasts) > 0:
            first_period = forecasts[0]
            print(f"  -> Forecast for '{first_period.get('name')}': {first_period.get('shortForecast')}")

            # Get Gemini alert
            gemini_alert = create_airport_alert(first_period.get('detailedForecast'))
            print(f"  -> Gemini Alert: {gemini_alert}")

            # Add new columns to the row dictionary
            new_row['forecast_name'] = first_period.get('name')
            new_row['forecast_startTime'] = pd.to_datetime(first_period.get('startTime'))
            new_row['forecast_temperature'] = first_period.get('temperature')
            new_row['forecast_temperatureUnit'] = first_period.get('temperatureUnit')
            new_row['forecast_windSpeed'] = first_period.get('windSpeed')
            new_row['forecast_windDirection'] = first_period.get('windDirection')
            new_row['forecast_shortForecast'] = first_period.get('shortForecast')
            new_row['forecast_detailedForecast'] = first_period.get('detailedForecast')
            new_row['gemini_alert'] = gemini_alert
        else:
            print("  -> No forecast data returned.")
            # Add empty values for new columns if no forecast
            new_row['forecast_name'] = None
            new_row['forecast_startTime'] = None
            new_row['forecast_temperature'] = None
            new_row['forecast_temperatureUnit'] = None
            new_row['forecast_windSpeed'] = None
            new_row['forecast_windDirection'] = None
            new_row['forecast_shortForecast'] = None
            new_row['forecast_detailedForecast'] = None
            new_row['gemini_alert'] = "No forecast available to generate alert."

        processed_airports.append(new_row)
        # Add a small delay to be respectful to the NWS API
        time.sleep(1)

    # 3. Create a new DataFrame with the enriched data
    results_df = pd.DataFrame(processed_airports)

    # 4. Load the new DataFrame into a new BigQuery table
    table_id = f"{PROJECT_ID}.{DATASET_ID}.{DESTINATION_TABLE}"
    print(f"\nLoading {len(results_df)} processed records to BigQuery table: `{table_id}`...")

    job_config = bigquery.LoadJobConfig(
        # Overwrite the table if it exists
        write_disposition="WRITE_TRUNCATE",
    )

    try:
        job = bq_client.load_table_from_dataframe(
            results_df, table_id, job_config=job_config
        )
        job.result()  # Wait for the job to complete
        print(f"Successfully created/updated table '{DESTINATION_TABLE}'.")

        # 5. Display the head of the new table
        print("\n--- Sample of the new table ---")
        display_columns = [
            'ident', 'name', 'municipality',
            'forecast_name', 'forecast_shortForecast', 'gemini_alert'
        ]
        # Ensure all columns exist before trying to display them
        display_columns_exist = [col for col in display_columns if col in results_df.columns]
        display(results_df[display_columns_exist].head())

    except Exception as e:
        print(f"Failed to load data into BigQuery: {e}")

else:
    print("No airports to process. Script finished.")